<!doctype html>
<html lang="en">
<head>
  <title>Three.js - WebVR - Basic w/background</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <script src="https://threejs.org/build/three.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mappa-mundi/dist/mappa.min.js" type="text/javascript"></script>

  <script src="https://d3js.org/d3-collection.v1.min.js"></script>
  <script src="https://d3js.org/d3-dispatch.v1.min.js"></script>
  <script src="https://d3js.org/d3-dsv.v1.min.js"></script>
  <script src="https://d3js.org/d3-request.v1.min.js"></script>
</head>
<style>
  html, body {
    position: relative;
      height: 100%;
      margin: 0;
  }
  #c {
      width: 100%;
      height: 100%;
      display: block;
  }
  .mode {
    position: absolute;
    right: 1em;
    top: 1em;
  }
  #VRButton {
    position: absolute;
    bottom: 20px;
    padding: 12px 6px;
    border: 1px solid rgb(255, 255, 255);
    border-radius: 4px;
    background: rgba(0, 0, 0, 0.1);
    color: rgb(255, 255, 255);
    font: 13px sans-serif;
    text-align: center;
    opacity: 0.5;
    outline: none;
    z-index: 999;
    cursor: pointer;
    left: calc(50% - 50px);
    width: 100px;
  }
</style>
<body>
  <canvas id="c"></canvas>
  <div class="mode">
    <a href="?allowvr=true" id="vr" style="float: right;">Allow VR</a>
    <a href="?" id="nonvr" style="display: none; float: right;">Use Non-VR Mode</a>
  </div>
  <script type="module">

  import * as THREE from 'https://threejsfundamentals.org/threejs/resources/threejs/r122/build/three.module.js';
  import {VRButton} from 'https://threejsfundamentals.org/threejs/resources/threejs/r122/examples/jsm/webxr/VRButton.js';
  import {OrbitControls} from 'https://threejsfundamentals.org/threejs/resources/threejs/r122/examples/jsm/controls/OrbitControls.js';

  function main() {

    var dataLoaded = false;
    var meteorites;
    var meshes = [];
    var material = new THREE.MeshLambertMaterial({color: 0xff0000, side: 2});

    d3.csv("data/Meteorite_Landings.csv", function(d) {
      return {
        lat: d.reclat,
        lng: d.reclong,
        size: d['mass (g)']
      };
    }, function(data) {
        meteorites = data;
        for (var i = 0; i < 100; i++){
            var radius = convertRange(data[i].size, [558, 60000000], [2, 15]);
            var tube = convertRange(data[i].size, [558, 60000000], [0.4, 4]);
            var geometry = new THREE.TorusGeometry( radius, tube, 16, 100 );
            meshes.push(new THREE.Mesh(geometry, material));
        }
        dataLoaded = true;
    });

    function convertRange( value, r1, r2 ) {
      return ( value - r1[ 0 ] ) * ( r2[ 1 ] - r2[ 0 ] ) / ( r1[ 1 ] - r1[ 0 ] ) + r2[ 0 ];
    }

    function getWidth() {
      return Math.max(
        document.body.scrollWidth,
        document.documentElement.scrollWidth,
        document.body.offsetWidth,
        document.documentElement.offsetWidth,
        document.documentElement.clientWidth
      );
    }

    function getHeight() {
      return Math.max(
        document.body.scrollHeight,
        document.documentElement.scrollHeight,
        document.body.offsetHeight,
        document.documentElement.offsetHeight,
        document.documentElement.clientHeight
      );
    }

    // Scene Configurations
    const WIDTH = getWidth();
    const HEIGHT = getHeight();
    const VIEW_ANGLE = 45;
    const ASPECT = WIDTH / HEIGHT;
    const NEAR = 0.1;
    const FAR = 10000;
    const FOV = 90;

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(FOV, ASPECT, NEAR, FAR);
    const canvas = document.querySelector('#c');
    const renderer = new THREE.WebGLRenderer({alpha: true, canvas: canvas});

    camera.position.set(0, 1.6, 300);
    scene.add(camera);
    renderer.setSize(WIDTH, HEIGHT);

    const params = (new URL(document.location)).searchParams;

    // temperary change to force vr
    //const allowvr = params.get('allowvr') === 'true';
    const allowvr = true;
    if (allowvr) {
      renderer.xr.enabled = true;
      document.body.appendChild(VRButton.createButton(renderer));
      document.querySelector('#vr').style.display = 'none';
      document.querySelector('#nonvr').style.display = 'inline';
    } else {
      // no VR, add some controls
      const controls = new OrbitControls(camera, canvas);
      controls.target.set(0, 1.6, -2);
      controls.update();
      document.querySelector('#nonvr').style.display = 'none';
      document.querySelector('#vr').style.display = 'inline';
    }

    // {
    //   const loader = new THREE.CubeTextureLoader();
    //   const texture = loader.load([
    //     'https://threejsfundamentals.org/threejs/resources/images/grid-1024.png',
    //     'https://threejsfundamentals.org/threejs/resources/images/grid-1024.png',
    //     'https://threejsfundamentals.org/threejs/resources/images/grid-1024.png',
    //     'https://threejsfundamentals.org/threejs/resources/images/grid-1024.png',
    //     'https://threejsfundamentals.org/threejs/resources/images/grid-1024.png',
    //     'https://threejsfundamentals.org/threejs/resources/images/grid-1024.png',
    //   ]);
    //   scene.background = texture;
    // }

    {
      const color = 0xFFFFFF;
      const intensity = 1;
      const light = new THREE.DirectionalLight(color, intensity);
      light.position.set(-1, 2, 4);
      scene.add(light);
    }

    const boxWidth = 1;
    const boxHeight = 1;
    const boxDepth = 1;
    const geometry = new THREE.BoxGeometry(boxWidth, boxHeight, boxDepth);

    function makeInstance(geometry, color, x) {
      const material = new THREE.MeshPhongMaterial({color});

      const cube = new THREE.Mesh(geometry, material);
      scene.add(cube);

      cube.position.x = x;
      cube.position.y = 1.6;
      cube.position.z = -2;

      return cube;
    }

    const cubes = [
      // makeInstance(geometry, 0x44aa88,  0),
      // makeInstance(geometry, 0x8844aa, -2),
      // makeInstance(geometry, 0xaa8844,  2),
    ];

    function resizeRendererToDisplaySize(renderer) {
      const canvas = renderer.domElement;
      const width = canvas.clientWidth;
      const height = canvas.clientHeight;
      const needResize = canvas.width !== width || canvas.height !== height;
      if (needResize) {
        renderer.setSize(width, height, false);
      }
      return needResize;
    }

    // API Key for Mapboxgl. Get one here:
    // https://www.mapbox.com/studio/account/tokens/
    const key = 'pk.eyJ1IjoibWFwcGF1c2VyIiwiYSI6ImNqNXNrbXIyZDE2a2cyd3J4Ym53YWxieXgifQ.JENDJqKE1SLISxL3Q_T22w'

    const options = {
      lat: 0,
      lng: 0,
      zoom: 2,
      pitch: 50,
    }

    const mappa = new Mappa('MapboxGL', key);
    const myMap = mappa.tileMap(options);
    myMap.overlay(canvas);
    myMap.onChange(update);

    function update() {
        if(dataLoaded){
            meshes.forEach(function(mesh, item){
                var pos = myMap.latLngToPixel(meteorites[item].lat , meteorites[item].lng);
                var vector = new THREE.Vector3();
                vector.set((pos.x / WIDTH) * 2 - 1, -(pos.y / HEIGHT) * 2 + 1, 0.5);
                vector.unproject(camera);
                var dir = vector.sub(camera.position).normalize();
                var distance = -camera.position.z / dir.z;
                var newPos = camera.position.clone().add(dir.multiplyScalar(distance));

                mesh.position.set(newPos.x, newPos.y, newPos.z);
                scene.add(mesh);
            })
        }
    }

    function render(time) {
      time *= 0.001;

      if (resizeRendererToDisplaySize(renderer)) {
        const canvas = renderer.domElement;
        camera.aspect = canvas.clientWidth / canvas.clientHeight;
        camera.updateProjectionMatrix();
      }

      meshes.forEach(function(mesh){
            mesh.rotation.x += 0.01;
            mesh.rotation.y += 0.01;
        })

      cubes.forEach((cube, ndx) => {
        const speed = 1 + ndx * .1;
        const rot = time * speed;
        cube.rotation.x = rot;
        cube.rotation.y = rot;
      });

      renderer.render(scene, camera);
    }

    renderer.setAnimationLoop(render);
  }

  main();

    </script>
  </body>
</html>
