// connect to signialling server
var connection = new WebSocket('ws://localhost:8000/socket'); 

let peer2connection = new RTCPeerConnection();
console.log("04. P2 creates a new RTCPeerConnection() object, peer2connection");

let peer2datachannel;
//peer2connection.ondatachannel = receiveChannelCallback;
console.log("05. P2 creates a placeholder data channel, peer2datachannel");

// when the signaling server sends something to peer2, parse it and react
connection.onmessage = function(signal) {

	// change the JSON keywords to lowercase
	// peer connection didnt like "Type" wanted "type"
    let message = JSON.parse(signal.data, function(prop, value) {
       var lower = prop.toLowerCase();
       if(prop === lower) return value;
       else this[lower] = value;
     });
 
    console.log("new message: ", message.type);

	switch (message.type) {

		case "offer":
			// handle data offer
			peer2HandleDataOffer(message);
			break;
		case 'candidate':
			//handle ice candidate		
			peer2HandleIceCandidate(message);
			
			break;
		default:
			console.log("P2: We got something from the signaling server but we don't know what it is!");
			console.log("Take a look for yourself:", signal);
	}
}

// handle data offer delivered by signal server
function peer2HandleDataOffer(message) {
	
	// set the remote description as the offer session description
	peer2connection.setRemoteDescription(message);
	console.log("09. P2 sets the received offer as its remote description");
	
	// create an answer to send back to peer 1 via the signaling server
	peer2connection.createAnswer().then((AnswerRTCSessionDescription) => {
	console.log("10. P2 creates a connection answer, AnswerRTCSessionDescription")

		// set the localdescription as the answer
		// setting Local Description triggers the peer2connection.onicecandidate event
		peer2connection.setLocalDescription(AnswerRTCSessionDescription);
		console.log("11. P2 sets the answer as its local description")


        //Prepare a message to send to peer 2
        // adjusted to suit PANO3D
        var data = AnswerRTCSessionDescription;
		message = {	
                        Type: data.type,
						SDP: data.sdp
					};
     
		console.log("12. P2 sends the answer to Pano3d in a JSON with some metadata via signaling server")

		// send AnswerRTCSessionDescription to peer1 via signaling server
		peer2SendMessageViaSignalingServer(message)
		
	});

}

// handle ice candidate delivered by signal server from peer 1
function peer2HandleIceCandidate(message) {
	
	// reformat candidate message from Pano3d
	var candidateMessage = {
		candidate: message.sdp,
		sdpMLineIndex: 0,
		sdpMid: ""
		
	}

	let candidate = new RTCIceCandidate(candidateMessage);

	// add the ice candidate to the connection
	peer2connection.addIceCandidate(candidate).then(() =>

		// it worked!
		console.log('    P1 Ice Candidate successfully added to peer2connection'),

		// it didn't work!
		err => {
			console.log('P2: Oh no! We failed to add the candidate');
			console.log("Here's the error:", err);
		});
}

// handle the onicecandidate events generated by setting of local description
peer2connection.onicecandidate = event => {
    
	// onicecandidates keep coming until an empty event is passed
	if (event.candidate) {
		// prepare a message to send to peer 2
		var data = event.candidate.candidate;
		let message = { Type: "candidate",
						SDP: data,
						Index: 0,
						Id: ""
					};
		console.log("ICE Candidate generated and handled by P2 and sent to PANO3D via signaling server")

		peer2SendMessageViaSignalingServer(message);
	} else {
		// no more candidates to send
		console.log("All P2 ICE candidates sent")
	}
}

// function peer2 uses to pass messages to signaling server 
function peer2SendMessageViaSignalingServer(message) {
    console.log("being sent:", message.Type);
    connection.send(JSON.stringify(message));
}



// listener for data channel 
peer2connection.ondatachannel = function(event) {
	console.log("a datachannel event - ondatachannel()");
	peer2datachannel = event.channel;
	
	// data datachannel opened 
	peer2datachannel.onopen = function(event) {
		console.log("data channel is opened - onopen()");
		peer2datachannel.binaryType = "arraybuffer";
		
	};
	
	peer2datachannel.onclose = function(event){
		console.log("The data channel was closed!");
	}

	// new data packet with pc
	// do the deocding here
	peer2datachannel.onmessage = function(event) {
		

		//  just the timestamp if you want to decode it
		// var etimestamp = new Uint8Array(event.data, 0, 9);
		// var dtimestamp = MessagePack.decode(etimestamp);

		// just the pose size and matrix if you want to decode it
		// TODO: 83 could be to small could be 90
		// var eposel = new Uint8Array(event.data, 9, 83);
		// var dposel = MessagePack.decode(eposel);	
		
		// just the point cloud arrayheader and array
		var epoint= new Uint8Array(event.data, 92);

		// if points are actually in the buffer
		// not just arrayheader
		if (epoint.byteLength > 93) {

			// var encoded = event.data; 
			// console.log("encoded", encoded);

			// decode it using imported msgpack library
			var dpoint = MessagePack.decode(epoint);
			console.log("Decoded pointarray:", dpoint);

			// create buffer from the decode Array
			var pointbuff = new Int8Array(dpoint);
			colate(pointbuff);
		}
		
	};
	  	
};

// will hold the entire point cloud
var pointcloud = new Int8Array();
var count = 0;

// function to add new points to growing point cloud buffer
function colate(newbuff) {

	// get the lengths of new and existing buffers
	var newlength = newbuff.byteLength;
	var oldlength = pointcloud.byteLength;
	
	var tempPointcloud = new Int8Array((newlength + oldlength));

	// add new points to existing points
	tempPointcloud.set(pointcloud);
	tempPointcloud.set(newbuff, oldlength);
	pointcloud = tempPointcloud;
	
	count ++;

	// download points after 500 data packets
	if (count > 500) {
		count = 0;
		downloadPC(pointcloud);
		
	}
		
}


// messy function to download the binary data of the point cloud
function downloadPC(rawPC) {

	function typedArrayToURL(typedArray, mimeType) {
		return URL.createObjectURL(new Blob([typedArray.buffer], {type: mimeType}))
	  }
	  	  
	const url = typedArrayToURL(rawPC, 'application/octet-stream');
	
	const link = document.createElement('a');
	link.href = url;
	link.download = "test55.bin";
	link.click();
	link.innerText = 'Bin file';
	
	document.body.appendChild(link);
	createGLTF(link, rawPC);
}

// function creates the gltf file specfication format for the
// latest buffer that just been downloaded 
// look at commented gltf file in img/ to understand whats going on here 
function createGLTF(link, cloud) {
	var length = cloud.byteLength;
	var uri = link.href; 
	var pointcount = length / 16;
	

	var gltf = {
		"asset": {
			"version": "2.0"
		},
		"scenes": [
			{
				"nodes": [
					0
				]
			}
		],
		"nodes": [
			{
				"mesh": 0
			}
		],
		"buffers": [
			{
				"byteLength": length,
				"uri": "test55.bin"
			}
		],
		"bufferViews": [
			{
				"buffer": 0,
				"byteOffset": 0,
				"byteLength": length,
				"byteStride": 16
			},
			{
				"buffer": 0,
				"byteOffset": 12,
				"byteLength": (length - 12),
				"byteStride": 16
			}
		],
		"accessors": [
			{
				"bufferView": 0,
				"byteOffset": 0,
				"componentType": 5126,
				"count": pointcount,
				"type": "VEC3"
			},
			{
				"bufferView": 1,
				"byteOffset": 0,
				"componentType": 5121,
				"count": pointcount,
				"type": "VEC3",
				"normalized": true
			}
		],
		"meshes": [
			{
				"primitives": [
					{
						"attributes": {
							"POSITION": 0,
							"COLOR_0": 1
						},
						"mode": 0
					}
				]
			}
		]
	};


	console.log(gltf);
	downloadGLTF(gltf);

}

// another messy function to download the gltf file
function downloadGLTF(gltf) {
	
	
	function typedArrayToURL(typedArray, mimeType) {
		return URL.createObjectURL(new File([typedArray], {type: mimeType}))
	}
	  	  
	const url = typedArrayToURL(JSON.stringify(gltf), 'text/plain');
	
	const link = document.createElement('a');
	link.href = url;
	link.setAttribute("download","test.gltf"); // dosnt work TODO fix.. 
	link.click();
	link.innerText = 'GLTF file';
	
	document.body.appendChild(link);
}



